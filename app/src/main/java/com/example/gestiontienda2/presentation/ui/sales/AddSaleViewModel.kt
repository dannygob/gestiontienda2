package com.gestiontienda2.presentation.ui.sales

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gestiontienda2.domain.models.Client
import com.gestiontienda2.domain.models.Product
import com.gestiontienda2.domain.models.Sale
import com.example.gestiontienda2.domain.models.SaleItem
import com.example.gestiontienda2.domain.usecases.AddSaleUseCase
import com.gestiontienda2.domain.usecases.GetClientsUseCase
import com.gestiontienda2.domain.usecases.GetProductsUseCase
import com.gestiontienda2.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AddSaleViewModel @Inject constructor(
    private val addSaleUseCase: AddSaleUseCase,
    private val getClientsUseCase: GetClientsUseCase, // Needed for client selection
    private val getProductsUseCase: GetProductsUseCase // Needed for product selection
) : ViewModel() {

    private val _selectedClient = MutableStateFlow<Client?>(null)
    val selectedClient: StateFlow<Client?> = _selectedClient.asStateFlow()

    private val _selectedProducts = MutableStateFlow<List<SaleItem>>(emptyList())
    val selectedProducts: StateFlow<List<SaleItem>> = _selectedProducts.asStateFlow()

    private val _totalAmount = MutableStateFlow(0.0)
    val totalAmount: StateFlow<Double> = _totalAmount.asStateFlow()

    private val _savingState = MutableStateFlow<SavingState>(SavingState.Idle)
    val savingState: StateFlow<SavingState> = _savingState.asStateFlow()

    // State for available clients and products for selection (optional, depending on UI approach)
    private val _clients = MutableStateFlow<List<Client>>(emptyList())
    val clients: StateFlow<List<Client>> = _clients.asStateFlow()

    private val _products = MutableStateFlow<List<Product>>(emptyList())
    val products: StateFlow<List<Product>> = _products.asStateFlow()


    init {
        loadClients()
        loadProducts()
    }

    private fun loadClients() {
        viewModelScope.launch {
            getClientsUseCase().collect { resource ->
                when (resource) {
                    is Resource.Success -> {
                        _clients.value = resource.data ?: emptyList()
                    }

                    is Resource.Error -> {
                        // Handle error loading clients
                    }

                    is Resource.Loading -> {
                        // Handle loading state for clients
                    }
                }
            }
        }
    }

    private fun loadProducts() {
        viewModelScope.launch {
            getProductsUseCase().collect { resource ->
                when (resource) {
                    is Resource.Success -> {
                        _products.value = resource.data ?: emptyList()
                    }

                    is Resource.Error -> {
                        // Handle error loading products
                    }

                    is Resource.Loading -> {
                        // Handle loading state for products
                    }
                }
            }
        }
    }

    fun selectClient(client: Client) {
        _selectedClient.value = client
    }

    fun addProductToSale(product: Product) {
        val currentItems = _selectedProducts.value.toMutableList()
        val existingItem = currentItems.find { it.productId == product.id }

        if (existingItem != null) {
            // If product already exists, increase quantity
            val updatedItem = existingItem.copy(quantity = existingItem.quantity + 1)
            _selectedProducts.value =
                currentItems.map { if (it.productId == product.id) updatedItem else it }
        } else {
            // If product is new, add with quantity 1
            val newItem = SaleItem(
                id = 0, // Will be generated by Room/Firebase
                saleId = 0, // Will be set when saving the sale
                productId = product.id,
                quantity = 1,
                priceAtSale = product.salePrice, // Capture price at the time of sale
                product = product // Include product details for display
            )
            _selectedProducts.value = currentItems + newItem
        }
        calculateTotal()
    }

    fun updateProductQuantity(saleItem: SaleItem, quantity: Int) {
        if (quantity <= 0) {
            removeProductFromSale(saleItem)
            return
        }
        val currentItems = _selectedProducts.value.toMutableList()
        val index =
            currentItems.indexOfFirst { it.id == saleItem.id } // Use unique ID if available, otherwise productId

        if (index != -1) {
            val updatedItem = currentItems[index].copy(quantity = quantity)
            currentItems[index] = updatedItem
            _selectedProducts.value = currentItems
            calculateTotal()
        }
    }

    fun removeProductFromSale(saleItem: SaleItem) {
        _selectedProducts.value =
            _selectedProducts.value.filter { it.id != saleItem.id } // Use unique ID if available, otherwise productId
        calculateTotal()
    }

    private fun calculateTotal() {
        _totalAmount.value = _selectedProducts.value.sumOf { it.quantity * it.priceAtSale }
    }

    fun saveSale() {
        viewModelScope.launch {
            _savingState.value = SavingState.Saving
            val client = _selectedClient.value
            val items = _selectedProducts.value

            if (client == null) {
                _savingState.value = SavingState.Error("Please select a client.")
                return
            }
            if (items.isEmpty()) {
                _savingState.value = SavingState.Error("Please add products to the sale.")
                return
            }

            val newSale = Sale(
                id = 0, // Will be generated by repository
                clientId = client.id,
                saleDate = System.currentTimeMillis(), // Or use a different date source
                totalAmount = _totalAmount.value,
                items = items.map { // Create new SaleItem instances without potentially outdated product details
                    SaleItem(
                        id = 0, // Will be generated by repository
                        saleId = 0, // Will be set by repository
                        productId = it.productId,
                        quantity = it.quantity,
                        priceAtSale = it.priceAtSale,
                        product = null // Don't save product details in the sale item itself in the domain model/data layer
                    )
                }
            )

            when (val result = addSaleUseCase(newSale)) {
                is Resource.Success -> {
                    _savingState.value = SavingState.Success(result.data)
                    // Clear form or navigate away on success
                    _selectedClient.value = null
                    _selectedProducts.value = emptyList()
                    _totalAmount.value = 0.0
                }

                is Resource.Error -> {
                    _savingState.value =
                        SavingState.Error(result.message ?: "Unknown error saving sale")
                }

                is Resource.Loading -> {
                    // Saving state is already set to Saving
                }
            }
        }
    }

    fun resetSavingState() {
        _savingState.value = SavingState.Idle
    }

    sealed class SavingState {
        object Idle : SavingState()
        object Saving : SavingState()
        data class Success(val saleId: Long?) : SavingState()
        data class Error(val message: String) : SavingState()
    }
}