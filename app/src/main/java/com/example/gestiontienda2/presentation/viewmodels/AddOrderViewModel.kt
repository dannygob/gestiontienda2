package com.your_app_name.presentation.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.your_app_name.domain.models.Order
import com.your_app_name.domain.models.OrderItem
import com.your_app_name.domain.models.OrderStatus
import com.your_app_name.domain.repository.OrderRepository
import com.your_app_name.domain.repository.ProductRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AddOrderViewModel @Inject constructor(
    private val orderRepository: OrderRepository,
    private val productRepository: ProductRepository // Inject ProductRepository
) : ViewModel() {

    private val _newOrder = MutableStateFlow(
        Order(
            id = 0, // Will be generated by the database
            clientId = 0, // TODO: Implement client selection and update this
            orderDate = System.currentTimeMillis(), // Default to current time
            status = OrderStatus.PENDING, // Default status
            items = emptyList(), // Start with an empty list of items
            totalAmount = 0.0 // Calculate based on items
        )
    )
    val newOrder: StateFlow<Order> = _newOrder.asStateFlow()

    private val _savingState = MutableStateFlow<SavingState>(SavingState.Idle)
    val savingState: StateFlow<SavingState> = _savingState.asStateFlow()

    private val _eventChannel = Channel<UiEvent>()
    val events = _eventChannel.receiveAsFlow()

    fun updateOrderDate(timestamp: Long) {
        _newOrder.value = _newOrder.value.copy(orderDate = timestamp)
    }

    fun updateClient(clientId: Int) {
        _newOrder.value = _newOrder.value.copy(clientId = clientId)
    }

    fun updateStatus(status: OrderStatus) {
        _newOrder.value = _newOrder.value.copy(status = status)
    }

    fun addItem(item: OrderItem) {
        val currentItems = _newOrder.value.items.toMutableList()
        currentItems.add(item)
        _newOrder.value =
            _newOrder.value.copy(items = currentItems, totalAmount = calculateTotal(currentItems))
    }

    fun updateItemQuantity(itemId: Int, quantity: Int) {
        val updatedItems = _newOrder.value.items.map { item ->
            if (item.id == itemId) {
                item.copy(quantity = quantity)
            } else {
                item
            }
        }
        _newOrder.value =
            _newOrder.value.copy(items = updatedItems, totalAmount = calculateTotal(updatedItems))
    }

    fun removeItem(itemId: Int) {
        val updatedItems = _newOrder.value.items.filterNot { it.id == itemId }
        _newOrder.value =
            _newOrder.value.copy(items = updatedItems, totalAmount = calculateTotal(updatedItems))
    }

    private fun calculateTotal(items: List<OrderItem>): Double {
        return items.sumOf { it.quantity * it.priceAtOrder }
    }

    fun saveOrder() {
        viewModelScope.launch {
            _savingState.value = SavingState.Saving
            try {
                val orderToSave = _newOrder.value
                val insufficientStockProduct = orderToSave.items.firstOrNull { item ->
                    viewModelScope.launch {
                        val product = productRepository.getProductById(item.productId)
                        return@launch product == null || product.stockQuantity - product.reservedStockQuantity < item.quantity
                    }.await() // Await the product check result for each item
                }

                if (insufficientStockProduct != null) {
                    // TODO: Get product name more gracefully if needed
                    _eventChannel.send(UiEvent.ShowSnackbar("Insufficient stock for a product.")) // More generic message for simplicity
                    return@launch // Stop saving if stock is insufficient for any item
                }
            }

            // If all items have sufficient stock, proceed to save and reserve
            val orderId = orderRepository.insertOrder(orderToSave)
            _savingState.value = SavingState.Success
            // Optionally reset _newOrder or navigate

            // Reserve stock for order items
            orderToSave.items.forEach { item ->
                val product = productRepository.getProductById(item.productId)
                product?.let {
                    productRepository.updateProduct(it.copy(reservedStockQuantity = it.reservedStockQuantity + item.quantity))
                }
            }

        } catch (e: Exception) {
            _savingState.value = SavingState.Error("Failed to save order: ${e.localizedMessage}")
        }
    }
}
}