package com.your_app_name.presentation.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.your_app_name.domain.models.Order
import com.your_app_name.domain.models.OrderItem
import com.your_app_name.domain.models.OrderStatus
import com.your_app_name.domain.repository.OrderRepository
import com.your_app_name.domain.repository.ProductRepository
import com.your_app_name.presentation.ui.UiEvent
import com.your_app_name.util.SavingState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AddOrderViewModel @Inject constructor(
    private val orderRepository: OrderRepository,
    private val productRepository: ProductRepository
) : ViewModel() {

    private val _newOrder = MutableStateFlow(
        Order(
            id = 0, // Will be generated by the database
            clientId = 0, // TODO: Implement client selection and update this
            orderDate = System.currentTimeMillis(), // Default to current time
            status = OrderStatus.PENDING, // Default status
            items = emptyList(), // Start with an empty list of items
            totalAmount = 0.0 // Calculate based on items
        )
    )
    val newOrder: StateFlow<Order> = _newOrder.asStateFlow()

    private val _savingState = MutableStateFlow<SavingState>(SavingState.Idle)
    val savingState: StateFlow<SavingState> = _savingState.asStateFlow()

    private val _eventChannel = Channel<UiEvent>()
    val events: Flow<UiEvent> = _eventChannel.receiveAsFlow()

    fun updateOrderDate(timestamp: Long) {
        _newOrder.value = _newOrder.value.copy(orderDate = timestamp)
    }

    fun updateClient(clientId: Int) {
        _newOrder.value = _newOrder.value.copy(clientId = clientId)
    }

    fun updateStatus(status: OrderStatus) {
        _newOrder.value = _newOrder.value.copy(status = status)
    }

    fun addItem(item: OrderItem) {
        val currentItems = _newOrder.value.items.toMutableList()
        currentItems.add(item)
        _newOrder.value = _newOrder.value.copy(
            items = currentItems,
            totalAmount = calculateTotal(currentItems)
        )
    }

    fun updateItemQuantity(itemId: Int, quantity: Int) {
        val updatedItems = _newOrder.value.items.map { item ->
            if (item.id == itemId) item.copy(quantity = quantity) else item
        }
        _newOrder.value = _newOrder.value.copy(
            items = updatedItems,
            totalAmount = calculateTotal(updatedItems)
        )
    }

    fun removeItem(itemId: Int) {
        val updatedItems = _newOrder.value.items.filterNot { it.id == itemId }
        _newOrder.value = _newOrder.value.copy(
            items = updatedItems,
            totalAmount = calculateTotal(updatedItems)
        )
    }

    private fun calculateTotal(items: List<OrderItem>): Double {
        return items.sumOf { it.quantity * it.priceAtOrder }
    }

    fun saveOrder() {
        viewModelScope.launch {
            _savingState.value = SavingState.Saving

            try {
                val orderToSave = _newOrder.value

                val insufficientStockProduct = orderToSave.items.firstOrNull { item ->
                    var hasInsufficientStock = false
                    val job = viewModelScope.launch {
                        val product = productRepository.getProductById(item.productId)
                        hasInsufficientStock = product == null ||
                            product.stockQuantity - product.reservedStockQuantity < item.quantity
                    }
                    job.join()
                    hasInsufficientStock
                }

                if (insufficientStockProduct != null) {
                    // TODO: Get product name more gracefully if needed
                    _eventChannel.send(UiEvent.ShowSnackbar("Insufficient stock for a product."))
                    _savingState.value = SavingState.Idle
                    return@launch
                }

                val orderId = orderRepository.insertOrder(orderToSave)
                _savingState.value = SavingState.Success

                // TODO: Optionally reset _newOrder or navigate

                // Reserve stock for order items
                orderToSave.items.forEach { item ->
                    viewModelScope.launch {
                        val product = productRepository.getProductById(item.productId)
                        product?.let {
                            val updatedProduct = it.copy(
                                reservedStockQuantity = it.reservedStockQuantity + item.quantity
                            )
                            productRepository.updateProduct(updatedProduct)
                        }
                    }
                }

            } catch (e: Exception) {
                _savingState.value = SavingState.Error("Failed to save order: ${e.localizedMessage}")
                _eventChannel.send(UiEvent.ShowSnackbar("Error saving order."))
            }
        }
    }
}
