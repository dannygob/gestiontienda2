package com.your_app_name.presentation.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.your_app_name.domain.models.OrderItem
import com.your_app_name.domain.models.OrderStatus
import com.your_app_name.domain.models.Order
import com.your_app_name.domain.repository.OrderRepository
import com.your_app_name.util.SavingState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AddOrderViewModel @Inject constructor(
    private val orderRepository: OrderRepository
) : ViewModel() {

    private val _newOrder = MutableStateFlow(
        Order(
            id = 0, // Will be generated by the database
            clientId = 0, // TODO: Implement client selection and update this
            orderDate = System.currentTimeMillis(), // Default to current time
            status = OrderStatus.PENDING, // Default status
            items = emptyList(), // Start with an empty list of items
            totalAmount = 0.0 // Calculate based on items
        )
    )
    val newOrder: StateFlow<Order> = _newOrder.asStateFlow()

    private val _savingState = MutableStateFlow<SavingState>(SavingState.Idle)
    val savingState: StateFlow<SavingState> = _savingState.asStateFlow()

    fun updateOrderDate(timestamp: Long) {
        _newOrder.value = _newOrder.value.copy(orderDate = timestamp)
    }

    fun updateClient(clientId: Int) {
         _newOrder.value = _newOrder.value.copy(clientId = clientId)
    }

    fun updateStatus(status: OrderStatus) {
        _newOrder.value = _newOrder.value.copy(status = status)
    }

    fun addItem(item: OrderItem) {
        val currentItems = _newOrder.value.items.toMutableList()
        currentItems.add(item)
        _newOrder.value = _newOrder.value.copy(items = currentItems, totalAmount = calculateTotal(currentItems))
    }

    fun updateItemQuantity(itemId: Int, quantity: Int) {
        val updatedItems = _newOrder.value.items.map { item ->
            if (item.id == itemId) {
                item.copy(quantity = quantity)
            } else {
                item
            }
        }
        _newOrder.value = _newOrder.value.copy(items = updatedItems, totalAmount = calculateTotal(updatedItems))
    }

     fun removeItem(itemId: Int) {
        val updatedItems = _newOrder.value.items.filterNot { it.id == itemId }
         _newOrder.value = _newOrder.value.copy(items = updatedItems, totalAmount = calculateTotal(updatedItems))
    }

    private fun calculateTotal(items: List<OrderItem>): Double {
        return items.sumOf { it.quantity * it.priceAtOrder }
    }

    fun saveOrder() {
        viewModelScope.launch {
            _savingState.value = SavingState.Saving
            try {
                // Ensure order has necessary data before saving
                val orderToSave = _newOrder.value
                if (orderToSave.clientId != 0) { // Basic validation: client must be selected
                    orderRepository.insertOrder(orderToSave)
                    _savingState.value = SavingState.Success
                    // Optionally reset _newOrder or navigate
                } else {
                    _savingState.value = SavingState.Error("Please select a client.")
                }
            } catch (e: Exception) {
                _savingState.value = SavingState.Error("Failed to save order: ${e.localizedMessage}")
            }
        }
    }
}

// You will need to define a sealed class for SavingState
/*
sealed class SavingState {
    object Idle : SavingState()
    object Saving : SavingState()
    data class Error(val message: String) : SavingState()
    object Success : SavingState()
}
*/